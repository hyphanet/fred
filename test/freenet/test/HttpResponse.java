package freenet.test;

import freenet.clients.http.Toadlet;
import freenet.clients.http.ToadletContextImpl;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Collections.emptyList;

/**
 * Simple parser and container for HTTP responses as generated by
 * {@link ToadletContextImpl} and friends.
 * <p style="font-weight: bold;">
 * This class should not be used for anything else! It’s blissfully unaware
 * of all the intricacies that HTTP brings with it! It is only meant to be
 * used in tests, to verify certain properties of HTTP responses generated
 * by {@link ToadletContextImpl} and other {@link Toadlet}-related
 * classes!
 * </p>
 * <h2>Usage</h2>
 * <p>
 * The intended use for this class is to turn a {@code byte[]} or
 * {@link String} into an {@link HttpResponse}, using one of the
 * {@code parse()} methods. After that, use one of the methods in
 * {@link HttpResponseMatchers} to verify that the HTTP response is
 * what you expect it to be.
 * </p>
 * <pre>
 * byte[] httpOutput = captureToadletOutput();
 * HttpResponse httpResponse = HttpResponse.parse(httpOutput);
 * assertThat(httpResponse, contains(hasStatus(200)));
 * </pre>
 *
 * @see HttpResponseMatchers
 */
public class HttpResponse {

	/**
	 * Parses the given HTTP response into one or more {@link HttpResponse}
	 * objects.
	 * <p>
	 * This method is equivalent to calling {@link #parse(byte[])} with the
	 * {@link String#getBytes(Charset) UTF-8 representation} of the given
	 * {@code String}.
	 * </p>
	 * <p style="font-weight: bold;">
	 * This class is <em>not</em> a generic, all-encompassing, or
	 * robust-in-any-way HTTP response parser! It will fail for anything
	 * that is too far away from what {@link ToadletContextImpl} and other
	 * {@link Toadlet}-related classes will generate!
	 * </p>
	 *
	 * @param response The response to parse
	 * @return The parsed response objects
	 * @see #parse(byte[])
	 */
	public static List<HttpResponse> parse(String response) {
		return parse(response.getBytes(UTF_8));
	}

	/**
	 * Parses the given HTTP response into one or more {@link HttpResponse}
	 * objects.
	 * <p>
	 * This method will throw exceptions with reckless abandon if anything is
	 * not as it’s supposed to be, like invalid response or header lines,
	 * missing header values, incorrect line terminators, invalid character
	 * encodings, or basically any other erroneous conditions.
	 * </p>
	 * <p style="font-weight: bold;">
	 * This class is <em>not</em> a generic, all-encompassing, or
	 * robust-in-any-way HTTP response parser! It will fail for anything
	 * that is too far away from what {@link ToadletContextImpl} and other
	 * {@link Toadlet}-related classes will generate!
	 * </p>
	 *
	 * @param response The response to parse
	 * @return The parsed response objects
	 */
	public static List<HttpResponse> parse(byte[] response) {
		List<HttpResponse> httpResponses = new ArrayList<>();
		int endOfLastLine = 0;
		while (endOfLastLine < response.length) {
			int endOfFirstLine = findNextLine(response, endOfLastLine);
			String firstLine = new String(response, endOfLastLine, endOfFirstLine - endOfLastLine, UTF_8);
			String[] firstLineParts = firstLine.trim().split(" ", 3);
			int statusCode = Integer.parseInt(firstLineParts[1]);
			HttpResponse httpResponse = new HttpResponse(statusCode, firstLineParts[2].trim());
			httpResponses.add(httpResponse);
			endOfLastLine = endOfFirstLine;
			while (true) {
				int endOfNextLine = findNextLine(response, endOfLastLine);
				String headerLine = new String(response, endOfLastLine, endOfNextLine - endOfLastLine, UTF_8).trim();
				endOfLastLine = endOfNextLine;
				if (headerLine.isEmpty()) {
					break;
				}
				String[] headerParts = headerLine.split(":", 2);
				httpResponse.addHeader(headerParts[0].trim(), headerParts[1].trim());
				if (endOfNextLine == response.length) {
					break;
				}
			}
			String contentLength = httpResponse.getHeaders("Content-Length").stream().findFirst().orElse(null);
			if (contentLength == null) {
				continue;
			}
			long length = Long.parseLong(contentLength);
			httpResponse.setBody(Arrays.copyOfRange(response, endOfLastLine, (int) (endOfLastLine + length)));
			endOfLastLine += (int) length;
		}
		return httpResponses;
	}

	/**
	 * Returns the HTTP status code of this response.
	 *
	 * @return The HTTP status code
	 */
	public int getStatusCode() {
		return statusCode;
	}

	/**
	 * Returns the HTTP status text of this reponse.
	 *
	 * @return The HTTP status text
	 */
	public String getStatusText() {
		return statusText;
	}

	/**
	 * Returns the names of all headers.
	 *
	 * @return The names of all headers
	 */
	public Set<String> getHeaders() {
		return headers.keySet();
	}

	/**
	 * Returns all header values for the header with the given name.
	 *
	 * @param name The name of the header to return values of
	 * @return The values of the header, in the order they have been
	 * 		encountered during parsing
	 */
	public List<String> getHeaders(String name) {
		return headers.getOrDefault(name.toLowerCase(), emptyList());
	}

	/**
	 * Returns the body of the response, or {@link Optional#empty()} if
	 * there is no response body.
	 *
	 * @return The response body
	 */
	public Optional<byte[]> getBody() {
		return Optional.ofNullable(body);
	}

	// not private because it’s used in HttpResponseMatcherTest
	HttpResponse(int statusCode, String statusText) {
		this.statusCode = statusCode;
		this.statusText = statusText;
	}

	// not private because it’s used in HttpResponseMatcherTest
	void addHeader(String name, String value) {
		headers.computeIfAbsent(name.toLowerCase(), key -> new ArrayList<>()).add(value);
	}

	// not private because it’s used in HttpResponseMatcherTest
	void setBody(byte[] body) {
		this.body = body;
	}

	private static int findNextLine(byte[] data, int offset) {
		int current = offset;
		while (current < data.length) {
			if (data[current] == '\n') {
				return current + 1;
			}
			current++;
		}
		return data.length;
	}

	private final int statusCode;
	private final String statusText;
	private final Map<String, List<String>> headers = new HashMap<>();
	private byte[] body = null;

}
